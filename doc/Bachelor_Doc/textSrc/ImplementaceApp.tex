\chapter{Implementace aplikace}
Před začátkem popisu implementace aplikace je vhodné upřesnit, jaký je její účel.  
Cílem aplikace je stahování dat z~API RÚIAN a jejich následné zpracování.  
Výsledkem bude projekce těchto dat do databáze, která bude sloužit jako zdroj pro další zpracování.  
Aplikace je napsána v~programovacím jazyce Java a~využívá framework Spring Boot.

\section{Projekce databáze}
Projekce databáze představuje způsob zobrazení dat z~jedné databáze do jiné.  
Podle konfigurace se nastavuje úroveň projekce, na jejímž základě se data zobrazují.  
Nastavení projekce je dále popsáno v~sekci~\ref{sec:konfigurace}.

\section{Architektura aplikace}
Architektura je rozdělena do několika modulů, z~nichž každý má svůj specifický úkol:
\begin{itemize}[itemsep=0pt]
    \item \textbf{main} -- hlavní modul aplikace, který obsahuje třídu \texttt{Main}, jež spouští celou aplikaci.
    \item \textbf{config} -- stará se o~konfiguraci aplikace a~její inicializaci.
    \item \textbf{download} -- zajišťuje stahování dat z~API RÚIAN a~následné zpracování těchto dat.
    \item \textbf{scheduler} -- spravuje spouštění úloh a~konfiguraci plánovače.
    \item \textbf{utils} -- obsahuje pomocné konstanty a~další užitečné nástroje.
\end{itemize}
Všechny závislosti a knihovny jsou spravovány pomocí nástroje \texttt{Maven}.

\section{Inicializace aplikace}
Na začátku běhu aplikace se provede její inicializace.  
Důvodem, proč byl zvolen framework Spring Boot, je schopnost aplikace automaticky načítat všechny komponenty a~konfigurace.  
Konkrétně se jedná o~moduly označené anotacemi \texttt{@Component}, \texttt{@Service}, \texttt{@Configuration}, \texttt{@Entity}, \texttt{@Repository} a~\texttt{@Bean}.

\subsection{Připojení k~databázi}
O připojení k~databázi se stará třída \texttt{DatabaseSource}, která zajišťuje navázání spojení s~databází.  
Z konfiguračního souboru se načtou potřebné informace pro připojení:
\begin{itemize}
    \item \texttt{type} -- typ databáze (např. \texttt{postgresql}, \texttt{mssql}, \texttt{oracle}),
    \item \texttt{url} -- adresa databáze (např. \texttt{localhost:5432} pro PostgreSQL),
    \item \texttt{dbname} -- název databáze (např. \texttt{ruian}),
    \item \texttt{username} -- uživatelské jméno pro připojení k~databázi,
    \item \texttt{password} -- heslo pro připojení k~databázi.
\end{itemize}

Na základě těchto informací se vytvoří připojení k~databázi, tzv. \textbf{DataSource}.  
\texttt{DataSource} slouží jako zdroj dat pro JPA a~zajišťuje správu spojení s~databází.  
Tento zdroj bude dále upravován v~jiném modulu.  
Základem \texttt{DataSource} je nastavení základních parametrů připojení.  
Vytváří se výsledný connection string, který se upravuje podle typu databáze.  
K URL se připojí název databáze, uživatelské jméno, heslo a~v~případě MSSQL také certifikát pro zabezpečené připojení.

V dalším modulu se pro \texttt{DataSource} nastavují další parametry potřebné pro přístup k~databázi a~přenos dat.  
Nejprve se inicializují DTO objekty, repozitáře a~třídy typu \texttt{Service} pro JPA.  
Tyto objekty jsou inicializovány pomocí anotace \texttt{@Autowired}, která zajišťuje injektování závislostí.  
Dále se nastaví dialekt pro správnou syntaxi SQL příkazů podle použité databáze.

\subsection{Načtení konfigurace}
\label{sec:konfigurace}

Zatímco \texttt{DatabaseSource} se stará pouze o~připojení k~databázi,  
třída \texttt{AppConfig} načítá zbytek potřebné konfigurace:
\begin{enumerate}
    \item \textbf{Konfigurace úkolů pro \texttt{Quartz Scheduler}}  
    Načítá se čas ve formátu cron pro spouštění přírůstkových dat  
    a~nastavení, zda přeskočit inicializaci hlavních územních prvků a~krajů.
    \item \textbf{Seznam krajů s~příslušnými kódy}  
    Každý řádek obsahuje kraj a~jeho kód.  
    Pokud je v~konfiguraci nastaveno přeskočení inicializace krajů nebo je seznam prázdný, tento krok se přeskočí.
    \item \textbf{Dodatečná nastavení}  
    Například volba pro ignorování geometrických dat  
    (některé databáze nepodporují geometrické typy)  
    a~nastavení velikosti jednotlivých commitů, které slouží pro optimalizaci výkonu.
    \item \textbf{Nastavení zpracování jednotlivých tabulek}  
    Základním parametrem je způsob zpracování tabulek: \texttt{all} nebo \texttt{selected}.  
    \begin{itemize}
        \item \textbf{all} -- všechny tabulky budou zpracovány bez ohledu na konfiguraci,
        \item \textbf{selected} -- budou zpracovány pouze tabulky výslovně uvedené v~konfiguraci.
    \end{itemize}
    \item \textbf{Konfigurace jednotlivých tabulek}  
    Pokud je nastaven režim \texttt{selected}, zpracovávají se pouze specifikované tabulky.  
    Každá tabulka může mít vlastní nastavení:
    \begin{lstlisting}[language=json, caption={Konfigurace tabulek}, label=lst:konfTabulek]
"<table_name>": {
    "howToProcess": "all | exclude | include",
    "columns": ["<column_name>", ..., "<column_name>"]
}
    \end{lstlisting}
    
    Možnosti zpracování:
    \begin{itemize}
        \item \textbf{all} -- všechny sloupce budou zpracovány,
        \item \textbf{exclude} -- vybrané sloupce budou ignorovány,
        \item \textbf{include} -- vybrané sloupce budou zpracovány.
    \end{itemize}

    \item \textbf{Sloupce} u jednotlivé tabulky jsou definovány jako pole řetězců s~názvy sloupců 
    ve formátu lowercase bez mezer a~speciálních znaků. Sloupce jsou odděleny čárkami.
    Sloupce nemusí být uvedeny pokud je nastaveno \texttt{all} u~konkrétní tabulky.
\end{enumerate}

\textbf{Možné chyby při načítání konfigurace:}
\begin{itemize}
    \item Pokud je nastaveno \texttt{exclude} nebo \texttt{include}, ale nejsou uvedeny žádné sloupce \textrightarrow{} neplatná konfigurace,
    \item Sloupce nebo tabulky, které neexistují v~databázi \textrightarrow{} budou přeskočeny,
    \item Seznam krajů je povinný atribut, i~pokud je prázdný. V~takovém případě budou zpracovány pouze základní územní prvky.
\end{itemize}

\newpage

\section{Quartz Scheduler}
Pro synchronizaci dat a~spouštění úloh v~určitých intervalech je použit \texttt{Quartz Scheduler}.  
Ten je přímo integrován do frameworku Spring Boot jako součást jedné z~jeho knihoven.  
Samotný scheduler se spouští při startu aplikace.

\subsection{Jobs}
\textit{Joby} jsou úlohy, které se spouštějí v~určitých intervalech nebo na základě určité události.  
V~našem případě se jedná o~3 úlohy:
\begin{itemize}
    \item \texttt{InitStatAzZsj}
    \item \texttt{InitRegion}
    \item \texttt{Additions}
\end{itemize}

\subsubsection*{InitStatAzZsj}
Tato úloha se spouští při startu aplikace a~je zodpovědná za inicializaci základních územních prvků a~krajů.  
Pokud je v~konfiguraci nastaveno přeskočení inicializace těchto prvků, úloha se neprovede.  
Úloha nejprve stáhne data o~základních územních prvcích a~krajích z~API RÚIAN za poslední měsíc.  
Následně se soubor zpracuje a~data se uloží do databáze.

\subsubsection*{InitRegion}
Tato úloha se spouští jako druhá, bezprostředně po dokončení úlohy \texttt{InitStatAzZsj}.  
Pokud je v~konfiguraci nastaveno přeskočení inicializace regionů, tato úloha se přeskočí.  
Úloha ze zadané konfigurace načte všechny kraje, které byly uvedeny.  
Každý kraj má přiřazen seznam obcí, které se postupně stahují z~API RÚIAN, zpracují a~uloží do databáze.

\subsubsection*{Additions}
Tato úloha se spouští na základě nastavení v~konfiguračním souboru nebo po dokončení úlohy \texttt{InitRegion}.  
Každý den je na API RÚIAN vytvořen nový soubor s~přírůstkovými daty za poslední den.  
Úloha tento soubor stáhne, zpracuje a~uloží do databáze.  
Poté čeká na další spuštění podle časového nastavení v~konfiguraci.

\subsection{Triggers}
\textit{Triggers} jsou spouštěče, které určují, kdy se má daný \texttt{job} spustit.  
Jak bylo zmíněno výše, úlohy \texttt{InitStatAzZsj} a~\texttt{InitRegion} se spouštějí jednorázově při startu aplikace a~navazují na sebe.  
Úloha \texttt{Additions} se naproti tomu spouští pravidelně podle nastavení v~konfiguračním souboru.  
Konkrétně je čas spuštění definován v~cron formátu.

\subsubsection*{Cron formát}
Cron formát je způsob, jak určit čas spouštění úloh.  
Původně byl použit v~systémech Unix a~stal se široce rozšířeným standardem.  
Skládá se z~následujících částí:
\begin{itemize}
    \item sekundy (0--59),
    \item minuta (0--59),
    \item hodina (0--23),
    \item den v~měsíci (1--31),
    \item měsíc (1--12 nebo zkratky názvů měsíců),
    \item den v~týdnu (0--6 nebo zkratky názvů dní).
\end{itemize}
Zkratky měsíců a~dnů se uvádějí v~angličtině, typicky ve formátu tří písmen (např. \texttt{JAN}, \texttt{MON}).
\textbf{Příklady:}
\begin{itemize}
    \item \texttt{0 0 2 * * ?} -- úloha se spustí každý den ve 2:00.
    \item \texttt{0 0 0 * * MON} -- úloha se spustí každé pondělí o~půlnoci.
    \item \texttt{30 14 3 JAN * ?} -- úloha se spustí 3.~ledna ve 14:30.
\end{itemize}

\newpage

\section{Získávání dat z~API}
Stahování dat z~API RÚIAN je realizováno pomocí tříd \texttt{VdpClient} a~\texttt{VdpDownload},  
které jsou součástí modulu \texttt{download}.

\subsection*{VdpDownload}
Třída \texttt{VdpDownload} se stará o~nastavení HTTP klienta s~důvěrou ke všem certifikátům.  
Využívá se zde knihovna \texttt{Apache HttpClient}, která je součástí Spring Boot.  
V~rámci metody \texttt{init()} se konfiguruje \texttt{SSLContext}, časové limity a~případně HTTP proxy.  
Výsledný klient je uložen do proměnné \texttt{client}, která se následně používá pro volání metod \texttt{tryGet()} a~\texttt{trySaveFilter()}.  
Tyto metody slouží ke stažení dat ze serveru VDP nebo k~inicializaci filtru pomocí HTTP požadavku.  
Před ukončením aplikace je klient uzavřen pomocí metody označené anotací \texttt{@PreDestroy}.

\subsection*{VdpClient}
\texttt{VdpClient} je hlavní komponenta pro komunikaci se službou Veřejného dálkového přístupu (VDP).  
Využívá celkem tři URL pro přístup k~seznamům souborů a~další tři URL pro stahování jednotlivých datových listů.  
Adresy jsou většinou nastaveny v~konstantách této třídy, s~výjimkou jedné, která si URL generuje dynamicky podle data předchozího dne.  
Pro samotné stahování dat používá instanci třídy \\ \texttt{VdpDownload}.
Třída obsahuje především tři metody, které jsou volány z~dříve popsaných \texttt{jobů}:
\begin{itemize}[itemsep=0pt]
    \item \texttt{zpracovatStatAzZsj()}
    \item \texttt{getListLinksObce()}
    \item \texttt{getAdditions()}
\end{itemize}

Každá z~těchto metod nejprve stáhne textový soubor, který obsahuje seznam dostupných datových souborů.  
Tento seznam se následně parsuje a~získané odkazy se využijí ke stažení souborů.  
Metody \texttt{zpracovatStatAzZsj()} a~\texttt{getAdditions()} stahují pouze jeden konkrétní soubor,  
zatímco \texttt{getListLinksObce()} stahuje všechny soubory dostupné v~seznamu.

Z~tohoto důvodu byla doplněna metoda \texttt{downloadFilesFromLinks()}, která umožňuje stáhnout všechny soubory uvedené v~daném seznamu.  
Získaná data jsou obvykle ve formátu ZIP, jsou automaticky rozbalena a~předána jako \texttt{InputStream} dalším komponentám  
prostřednictvím funkčního rozhraní \texttt{Consumer}.  

Třída rovněž implementuje opakování požadavků v~případě selhání, logování a~čištění dočasných souborů.

\newpage

\section{Zpracování dat}
Jak bylo zmíněno výše, data jsou zpracovávána pomocí třídy \texttt{VdpClient} 
a pomocí funkčního rozhraní \texttt{Consumer} se předávají dalším komponentám.
A to právě komponentě \texttt{VdpParser}, která se stará o~parsování XML souboru v předaném \texttt{InputStream} 
dat a následné ukládání do databáze.

Na začátku se zinicializuje \texttt{XMLStreamReader}, který se stará o~parsování XML souboru. 
Reader je vytvořen pomocí třídy \texttt{XMLInputFactory}, která je součástí \\ knihovny \texttt{StAX}.

Původně byl použit \texttt{DocumentBuilder}, ale ten byl nahrazen \texttt{StAX} parserem.
Celé soubory si nejprve načítal do paměti a~poté je parsoval, po prvcích (Node).
To bylo v~případě malých souborů (příklad při zpracování malých obcí). 
Problém nastal při zpracování velkých souborů (např. obec Praha),
Soubor dosahoval velikosti přes 1 GB a~bylo potřeba jej zpracovat po částech.
Je ale velmi náročné dělit XML bez rozbití struktury souboru.
Proto se později přešlo na \texttt{StAX} parser, který zpracovává XML po prvcích a~nepotřebuje celou strukturu XML.
\texttt{StAX} parser je mnohem efektivnější a~umožňuje zpracovávat velké soubory bez nutnosti načítat je celé do paměti.
Zároveň čte pouze události jako je začátek a~konec elementu, což je pro zpracování dat dostačující.
Stačí tedy nadefinovat jen název potřebných elementů a~tyto elementy parsovat.
U \texttt{DocumentBuilderu} bylo třeba číst všechny Listy a~poté je zpracovávat.

\subsection{Parsing dat}
Jak už bylo řečeno výše, data jsou parsována ve třídě \texttt{VdpParser} s použitím \texttt{XMLStreamReader}.
Zároveň ve stejném modulu se nachází i třída \texttt{VdpParserConsts}, která obsahuje konstanty pro názvy jednotlivých elementů.
Při čtení XML se nejprve čte hlavička souboru. Ta obsahuje nepotřebné informace, které se ignorují.
Dále se čtou jednotlivá data počínající elementem \texttt{vf:Data}.
Nejprve je potřeba ale rozeznat jaký element se čte.
\texttt{XMLStreamReader} rozeznává několik eventů a u každého eventu se provádí jiná akce a získává jiná informace.
\begin{table}[!h]
    \begin{tabular}{|l|c|c|c|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Event}} & \textbf{Hodnota Event} & \textbf{Důležitá informace} & \textbf{Příklad}                                 \\ \hline
    \textit{START\_ELEMENT}              & 1                      & Název Elementu              & \textless{}vf:Data\textgreater{}                 \\ \hline
    \textit{END\_ELEMENT}                & 2                      & Název Elementu              & \textless{}\textbackslash{}vf:Data\textgreater{} \\ \hline
    \textit{CHARACTERS}                  & 4                      & Hodnoty                     & Data                                             \\ \hline
    \end{tabular}
\end{table}

Příkladem pokud se vyskytne event \texttt{START\_ELEMENT} tak z něj můžu získat název elementu a~jeho atributy.
Pokud se vyskytne event \texttt{CHARACTERS}, tak z něj získám text uvnitř elementu, ale pokud se pokusím získat jméno elementu vyhodí to výjimku.

Cílem je tedy číst data v v cyklu dokud nenarazím na konec elementu \texttt{vf:Data}.
V průběhu čtení se nachází další důležité elementy, které určují co se zrovna čte za objekt.
Jeden soubor může rozeznávat až 19 různých objektů, které se parsují do různých DTO objektů.
Každý jeden objekt podléhá jinému seznamu objektů.
Je tedy potřeba rozeznat kdy začíná list a kdy jeden objekt.
\begin{table}[!h]
    \label{tab:seznamObjektu}
    \caption{Seznam objektů a~jejich názvy}
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Název}                       & \textbf{List Počátek/konec}                    & \textbf{Objekt Počátek/Konec}                 \\ \hline
    \textit{Stát}                        & \textless{}vf:Staty\textgreater{}              & \textless{}vf:Stat\textgreater{}              \\ \hline
    \textit{Region Soudržnosti}          & \textless{}vf:RegionySourdznosti\textgreater{} & \textless{}vf:RegionSourdznosti\textgreater{} \\ \hline
    \textit{VUSC}                        & \textless{}vf:Vusc\textgreater{}               & \textless{}vf:Vusc\textgreater{}              \\ \hline
    \textit{Okres}                       & \textless{}vf:Okresy\textgreater{}             & \textless{}vf:Okres\textgreater{}             \\ \hline
    \textit{ORP}                         & \textless{}vf:Orp\textgreater{}                & \textless{}vf:Orp\textgreater{}               \\ \hline
    \textit{POU}                         & \textless{}vf:Pou\textgreater{}                & \textless{}vf:Pou\textgreater{}               \\ \hline
    \textit{Obce}                        & \textless{}vf:Obce\textgreater{}               & \textless{}vf:Obec\textgreater{}              \\ \hline
    \textit{Spravní Obvod}               & \textless{}vf:SpravniObvody\textgreater{}      & \textless{}vf:SpravniObvod\textgreater{}      \\ \hline
    \textit{MOP}                         & \textless{}vf:Mop\textgreater{}                & \textless{}vf:Mop\textgreater{}               \\ \hline
    \textit{MOMC}                        & \textless{}vf:Momc\textgreater{}               & \textless{}vf:Momc\textgreater{}              \\ \hline
    \textit{Část Obce}                   & \textless{}vf:CastiObci\textgreater{}          & \textless{}vf:CastiObce\textgreater{}         \\ \hline
    \textit{Katastrální Území}           & \textless{}vf:KatastralniUzemi\textgreater{}   & \textless{}vf:KatastralniUzemi\textgreater{}  \\ \hline
    \textit{Parcela}                     & \textless{}vf:Parcely\textgreater{}            & \textless{}vf:Parcely\textgreater{}           \\ \hline
    \textit{Ulice}                       & \textless{}vf:Ulice\textgreater{}              & \textless{}vf:Ulice\textgreater{}             \\ \hline
    \textit{Stavební Objekt}             & \textless{}vf:StavebniObjekty\textgreater{}    & \textless{}vf:StavebniObjekt\textgreater{}    \\ \hline
    \textit{Adresní Místo}               & \textless{}vf:AdresniMista\textgreater{}       & \textless{}vf:AdresniMisto\textgreater{}      \\ \hline
    \textit{ZSJ}                         & \textless{}vf:Zsj\textgreater{}                & \textless{}vf:Zsj\textgreater{}               \\ \hline
    \textit{VO}                          & \textless{}vf:VO\textgreater{}                 & \textless{}vf:VO\textgreater{}                \\ \hline
    \textit{Zaniklý Prvek}               & \textless{}vf:ZaniklePrvky\textgreater{}       & \textless{}vf:ZaniklyPrvek\textgreater{}      \\ \hline
    \end{tabular}
\end{table}

\small
\begin{lstlisting}[language=xml, caption={Příklad XML Struktury}, label=lst:vfStruktura]
<vf:Data>
    <vf:Staty>
        <sti:Stat>
            <sti:Kod>...</sti:Kod>
        </sti:Stat>
    </vf:Staty>
<\vf:Data>
\end{lstlisting}
\normalsize

Každý element je rozdělen na dvě části.
Klasifikátor a~název elementu.
Klasifikátor je určen pro rozlišení jednotlivých elementů do jaké úrovně patří.
Podle názvu elementu se určuje jaký objekt se parsuje.
V příkladu \ref{lst:vfStruktura} je uveden \texttt{vf} klasifikátor (\textit{výměnný formát}), který je nejvyšší úrovní.
Každý list objektů také používá tento klasifikátor, ale každý objekt má jiný klasifikátor.
Každý objekt má následně atributy, s klasifikátorem objektu. Pokud je atribut cizí klíč používá klasifikátor odkazovaného objektu.
Příklad \texttt{vf:Staty} a~\texttt{sti:Stat}.
Dále se může vyskytnout i atribut, který je v další tabulka nebo list tabulek. Tyto tabulky používají klasifikátor \texttt{com}.
\small
\begin{lstlisting}[language=xml, caption={Příklad Klasifikátorů}, label=lst:klasifikator]
<vf:Data>
    <vf:Okresy>
        <vf:Okres>
            <oki:Kod>100</oki:Kod>
            <oki:Nazev>...</oki:Nazev>
        <\vf:Okres>
    </vf:Okresy>
    <vf:Obce>
        <vf:Obec>
            <obi:Kod>...</obi:Kod>
            <obi:Nazev>...</obi:Nazev>
            <obi:Okres>
            <oki:Kod>100<oki:Kod>
            </obi:Okres>
            <obi:MluvnickeCharakteristiky>
                <com:Pad2>...</com:Pad2>
                <com:Pad3>...</com:Pad3>
            </obi:MluvnickeCharakteristiky>
        </vf:Obec>
    </vf:Obce>
</vf:Data>
\end{lstlisting}
\normalsize

\subsection{Atributy Objektů}
V tabulce \ref{tab:datove_typy} byly zmíněné všechny datové typy a jejich rozdíly mezi databázemi.
Podle dokumentace RÚIAN VFR \cite{ruian_vfr} každý atribut objektu má také svůj datový typ.
Mezi datovými objektů se nachází:
\begin{itemize}
    \item \textbf{String} -- textový řetězec, který může obsahovat písmena, číslice a~speciální znaky.
    \item \textbf{Integer} -- celé číslo bez desetinné části.
    \item \textbf{Long} -- reálné číslo s~desetinnou částí.
    \item \textbf{Boolean} -- logická hodnota, která může nabývat hodnoty true nebo false.
    \item \textbf{DateTime} -- datum a~čas ve formátu YYYY-MM-DDTHH:MM:SS.
    \item \textbf{Kolekce} -- seznam objektů nebo hodnot, které jsou uloženy v~jednom atributu.
\end{itemize}

Datové typy jako \texttt{String}, \texttt{Integer}, \texttt{Boolean} a~\texttt{Long} jsou standardní datové typy.
Ovšem zmíněné \texttt{Kolekce} jsou označeny všechny atributy, které obsahují více hodnot nebo cizí klíče.
Kolekce budou do databáze ukládány jako \textbf{JSON}.

\subsubsection*{JSON Objekty}
Proč byly zvoleny JSON objekty? Tabulky dle specifikace nebyly vhodné pro rozdělení na další tabulky a~vytváření cizích klíčů.
Některé kolekce totiž mohou být 1:1 nebo N:M. Proto byl zvolen JSON formát, který je vhodný pro ukládání takových to dat.
Některé kolekce jsou uloženy jako JSON Objekt a některé jako JSON pole (Pole JSON Objektů).
Byl proto vytvořen pro každou kolekci vlastní JSON mapovací metoda. Každá tato metoda funguje podobně jako XML parser.
Hledá elementy, které jsou uloženy v~kolekci a~převede je na JSON objekt nebo pole.
Všechny atributy, které se mohou vyskytnout json definován jako konstanty v modulu \texttt{jsonObjects} s příslušným jménem k objektu.

\subsubsection*{Kolekce JSON Objekt}
Tyto kolekce vždy obsahují pouze jeden JSON Objekt.
Proto byl vytvořen pro každou kolekci vlastní metoda, která parsuje danou kolekci.
Jedná se o~kolekce:
\begin{itemize}
    \item \textbf{Mluvnické Charakteristiky} -- metoda \texttt{readMCh()}
    \item \textbf{Čísla domovní} -- metoda \texttt{readCislaDomovni()}
    \item \textbf{Nespravné Údaje} -- metoda \texttt{readNespravneUdaje()}
\end{itemize}

\subsubsection*{Kolekce JSON Pole}
Tyto kolekce mohou obsahovat jednu nebo více Objektů.
Proto byl vytvořen pro každou kolekci vlastní metoda, která parsuje danou kolekci.
Jedná se o kolekce:
\begin{itemize}
    \item \textbf{Bonitované díly / Bonitovaný díl} -- metoda \texttt{readBonitovaneDily()} a \texttt{readBonitovanyDil()}
    \item \textbf{Způsoby ochrany / Způsob ochrany} -- metoda \texttt{readZpusobyOchrany()} a \texttt{readZpusobOchrany()}
    \item \textbf{DetailniTEA} -- metoda \texttt{readDetailniTeas()} a \texttt{readDetailniTea()}
\end{itemize}

V přírůstkových datech se nachází i další kolekce a to \textbf{Nezjištěné údaje}.
Ta je je kompletně ignorována a~neukládá se do databáze.


\subsubsection*{Kolekce s cizími klíči}
Jak již bylo zmíněno, cizí klíče jsou jako kolekce uloženy Integer nebo Long.
Vzhledem k tomu, že se jedná o~cizí klíče, které odkazují na jiné objekty,
byly vytvořeny metody pro parsování těchto cizích klíčů.
Metoda \texttt{readFK()} a \texttt{readFKLong} dostane jako parametr název elementu a vrací Integer nebo Long.
Rozdělení na Integer a Long je z důvodu, že je zde objekt \textbf{Parcela}, která má primární klíč jako Long.

\subsubsection*{Geometrie}
Geometrie je uložena speciální kolekce obsahující až 3 možné geometrické údaje.
V základní datové sadě se nachází pouze Definiční bod specifikující střed daného objektu na mapě.
V rozšířených se pak dodatečně nachází i Generalizované Hranice a Originální Hranice.
Je zde i případ Definiční čáry, která je uložena jako \texttt{LineString} nebo \texttt{MultiLineString}.
Tato geometrie se vyskytuje pouze u objektů \textbf{Ulice}.
O problematiku parsování geometrie se stará třída \texttt{GeometryParser} v modulu \texttt{geometry}, která parsuje jednotlivé geometrické objekty.
V současné práci se řeší pouze Definiční bod, který je uložen jako \texttt{Point} nebo \texttt{MultiPoint}.
Generalizované Hranice a Originální Hranice jsou uloženy jako \texttt{Polygon} nebo \texttt{MultiPolygon}.
Stejně jako u JSON objektů i geometrie se čte podle eventu a atributů v elementu.
Názvy geometrických objektů jsou uloženy jako konstanty v modulu \texttt{geometryParserConsts} s příslušným jménem k objektu.
Výstupem všech metod pro parsování geometrie je \texttt{Geometry} objekt z knihovny \texttt{JTS}.


\subsection{Dto objekty}
\subsection{Repositáře}
\subsection{Service třídy}
\subsection{Validace dat}
\subsection{Ukládání dat do databáze}