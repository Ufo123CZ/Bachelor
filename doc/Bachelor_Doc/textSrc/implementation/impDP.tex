
\section{Získávání dat z~API}
Stahování dat z~API RÚIAN je realizováno pomocí tříd \texttt{VdpClient} a~\texttt{VdpDownload},  
které jsou součástí modulu \texttt{download}.

\subsection*{VdpDownload}
Třída \texttt{VdpDownload} se stará o~nastavení HTTP klienta s~důvěrou ke všem certifikátům.  
Využívá se zde knihovna \texttt{Apache HttpClient}, která je součástí Spring Boot.  
V~rámci metody \texttt{init()} se konfiguruje \texttt{SSLContext}, časové limity a~případně HTTP proxy.  
Výsledný klient je uložen do proměnné \texttt{client}, která se následně používá pro volání metod \texttt{tryGet()} a~\texttt{trySaveFilter()}.  
Tyto metody slouží ke stažení dat ze serveru VDP nebo k~inicializaci filtru pomocí HTTP požadavku.  
Před ukončením aplikace je klient uzavřen pomocí metody označené anotací \texttt{@PreDestroy}.

\subsection*{VdpClient}
\texttt{VdpClient} je hlavní komponenta pro komunikaci se službou Veřejného dálkového přístupu (VDP).  
Využívá celkem tři URL pro přístup k~seznamům souborů a~další tři URL pro stahování jednotlivých datových listů.  
Adresy jsou většinou nastaveny v~konstantách této třídy, s~výjimkou jedné, která si URL generuje dynamicky podle data předchozího dne.  
Pro samotné stahování dat používá instanci třídy \\ \texttt{VdpDownload}.
Třída obsahuje především tři metody, které jsou volány z~dříve popsaných \texttt{jobů}:
\begin{itemize}[itemsep=0pt]
    \item \texttt{zpracovatStatAzZsj()}
    \item \texttt{getListLinksObce()}
    \item \texttt{getAdditions()}
\end{itemize}

Každá z~těchto metod nejprve stáhne textový soubor, který obsahuje seznam dostupných datových souborů.  
Tento seznam se následně parsuje a~získané odkazy se využijí ke stažení souborů.  
Metody \texttt{zpracovatStatAzZsj()} a~\texttt{getAdditions()} stahují pouze jeden konkrétní soubor,  
zatímco \texttt{getListLinksObce()} stahuje všechny soubory dostupné v~seznamu.

Z~tohoto důvodu byla doplněna metoda \texttt{downloadFilesFromLinks()}, která umožňuje stáhnout všechny soubory uvedené v~daném seznamu.  
Získaná data jsou obvykle ve formátu ZIP, jsou automaticky rozbalena a~předána jako \texttt{InputStream} dalším komponentám  
prostřednictvím funkčního rozhraní \texttt{Consumer}.  

Třída rovněž implementuje opakování požadavků v~případě selhání, logování a~čištění dočasných souborů.

\newpage

\section{Zpracování dat}
Jak bylo zmíněno výše, data jsou zpracovávána pomocí třídy \texttt{VdpClient} 
a pomocí funkčního rozhraní \texttt{Consumer} se předávají dalším komponentám.
A to právě komponentě \texttt{VdpParser}, která se stará o~parsování XML souboru v předaném \texttt{InputStream} 
dat a následné ukládání do databáze.

Na začátku se zinicializuje \texttt{XMLStreamReader}, který se stará o~parsování XML souboru. 
Reader je vytvořen pomocí třídy \texttt{XMLInputFactory}, která je součástí \\ knihovny \texttt{StAX}.

Původně byl použit \texttt{DocumentBuilder}, ale ten byl nahrazen \texttt{StAX} parserem.
Celé soubory si nejprve načítal do paměti a~poté je parsoval, po prvcích (Node).
To bylo v~případě malých souborů (příklad při zpracování malých obcí). 
Problém nastal při zpracování velkých souborů (např. obec Praha),
Soubor dosahoval velikosti přes 1 GB a~bylo potřeba jej zpracovat po částech.
Je ale velmi náročné dělit XML bez rozbití struktury souboru.
Proto se později přešlo na \texttt{StAX} parser, který zpracovává XML po prvcích a~nepotřebuje celou strukturu XML.
\texttt{StAX} parser je mnohem efektivnější a~umožňuje zpracovávat velké soubory bez nutnosti načítat je celé do paměti.
Zároveň čte pouze události jako je začátek a~konec elementu, což je pro zpracování dat dostačující.
Stačí tedy nadefinovat jen název potřebných elementů a~tyto elementy parsovat.
U \texttt{DocumentBuilderu} bylo třeba číst všechny Listy a~poté je zpracovávat.

\subsection{Parsing dat}
Jak už bylo řečeno výše, data jsou parsována ve třídě \texttt{VdpParser} s použitím \\ \texttt{XMLStreamReader}.
Zároveň ve stejném modulu se nachází i třída \texttt{VdpParserConsts}, která obsahuje konstanty pro názvy jednotlivých elementů.
Při čtení XML se nejprve čte hlavička souboru. Ta obsahuje nepotřebné informace, které se ignorují.
Dále se čtou jednotlivá data počínající elementem \texttt{vf:Data}.
Nejprve je potřeba ale rozeznat jaký element se čte.
\texttt{XMLStreamReader} rozeznává několik eventů a u každého eventu se provádí jiná akce a získává jiná informace.
\begin{table}[!h]
    \begin{tabular}{|l|c|c|c|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Event}} & \textbf{Hodnota Event} & \textbf{Důležitá informace} & \textbf{Příklad}                                 \\ \hline
    \textit{START\_ELEMENT}              & 1                      & Název Elementu              & \textless{}vf:Data\textgreater{}                 \\ \hline
    \textit{END\_ELEMENT}                & 2                      & Název Elementu              & \textless{}\textbackslash{}vf:Data\textgreater{} \\ \hline
    \textit{CHARACTERS}                  & 4                      & Hodnoty                     & Data                                             \\ \hline
    \end{tabular}
\end{table}

Příkladem pokud se vyskytne event \texttt{START\_ELEMENT} tak z něj můžu získat název elementu a~jeho atributy.
Pokud se vyskytne event \texttt{CHARACTERS}, tak z něj získám text uvnitř elementu, ale pokud se pokusím získat jméno elementu vyhodí to výjimku.

Cílem je tedy číst data v v cyklu dokud nenarazím na konec elementu \texttt{vf:Data}.
V průběhu čtení se nachází další důležité elementy, které určují co se zrovna čte za objekt.
Jeden soubor může rozeznávat až 19 různých objektů, které se parsují do různých DTO objektů.
Každý jeden objekt podléhá jinému seznamu objektů.
Je tedy potřeba rozeznat kdy začíná list a kdy jeden objekt.
\begin{table}[!h]
    \label{tab:seznamObjektu}
    \caption{Seznam objektů a~jejich názvy}
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Název}                       & \textbf{List Počátek/konec}                    & \textbf{Objekt Počátek/Konec}                 \\ \hline
    \textit{Stát}                        & \textless{}vf:Staty\textgreater{}              & \textless{}vf:Stat\textgreater{}              \\ \hline
    \textit{Region Soudržnosti}          & \textless{}vf:RegionySourdznosti\textgreater{} & \textless{}vf:RegionSourdznosti\textgreater{} \\ \hline
    \textit{VUSC}                        & \textless{}vf:Vusc\textgreater{}               & \textless{}vf:Vusc\textgreater{}              \\ \hline
    \textit{Okres}                       & \textless{}vf:Okresy\textgreater{}             & \textless{}vf:Okres\textgreater{}             \\ \hline
    \textit{ORP}                         & \textless{}vf:Orp\textgreater{}                & \textless{}vf:Orp\textgreater{}               \\ \hline
    \textit{POU}                         & \textless{}vf:Pou\textgreater{}                & \textless{}vf:Pou\textgreater{}               \\ \hline
    \textit{Obce}                        & \textless{}vf:Obce\textgreater{}               & \textless{}vf:Obec\textgreater{}              \\ \hline
    \textit{Spravní Obvod}               & \textless{}vf:SpravniObvody\textgreater{}      & \textless{}vf:SpravniObvod\textgreater{}      \\ \hline
    \textit{MOP}                         & \textless{}vf:Mop\textgreater{}                & \textless{}vf:Mop\textgreater{}               \\ \hline
    \textit{MOMC}                        & \textless{}vf:Momc\textgreater{}               & \textless{}vf:Momc\textgreater{}              \\ \hline
    \textit{Část Obce}                   & \textless{}vf:CastiObci\textgreater{}          & \textless{}vf:CastiObce\textgreater{}         \\ \hline
    \textit{Katastrální Území}           & \textless{}vf:KatastralniUzemi\textgreater{}   & \textless{}vf:KatastralniUzemi\textgreater{}  \\ \hline
    \textit{Parcela}                     & \textless{}vf:Parcely\textgreater{}            & \textless{}vf:Parcely\textgreater{}           \\ \hline
    \textit{Ulice}                       & \textless{}vf:Ulice\textgreater{}              & \textless{}vf:Ulice\textgreater{}             \\ \hline
    \textit{Stavební Objekt}             & \textless{}vf:StavebniObjekty\textgreater{}    & \textless{}vf:StavebniObjekt\textgreater{}    \\ \hline
    \textit{Adresní Místo}               & \textless{}vf:AdresniMista\textgreater{}       & \textless{}vf:AdresniMisto\textgreater{}      \\ \hline
    \textit{ZSJ}                         & \textless{}vf:Zsj\textgreater{}                & \textless{}vf:Zsj\textgreater{}               \\ \hline
    \textit{VO}                          & \textless{}vf:VO\textgreater{}                 & \textless{}vf:VO\textgreater{}                \\ \hline
    \textit{Zaniklý Prvek}               & \textless{}vf:ZaniklePrvky\textgreater{}       & \textless{}vf:ZaniklyPrvek\textgreater{}      \\ \hline
    \end{tabular}
\end{table}

\small
\begin{lstlisting}[language=xml, caption={Příklad XML Struktury}, label=lst:vfStruktura]
<vf:Data>
    <vf:Staty>
        <sti:Stat>
            <sti:Kod>...</sti:Kod>
        </sti:Stat>
    </vf:Staty>
<\vf:Data>
\end{lstlisting}
\normalsize

Každý element je rozdělen na dvě části.
Klasifikátor a~název elementu.
Klasifikátor je určen pro rozlišení jednotlivých elementů do jaké úrovně patří.
Podle názvu elementu se určuje jaký objekt se parsuje.
V příkladu \ref{lst:vfStruktura} je uveden \texttt{vf} klasifikátor (\textit{výměnný formát}), který je nejvyšší úrovní.
Každý list objektů také používá tento klasifikátor, ale každý objekt má jiný klasifikátor.
Každý objekt má následně atributy, s klasifikátorem objektu. Pokud je atribut cizí klíč používá klasifikátor odkazovaného objektu.
Příklad \texttt{vf:Staty} a~\texttt{sti:Stat}.
Dále se může vyskytnout i atribut, který je v další tabulka nebo list tabulek. Tyto tabulky používají klasifikátor \texttt{com}.

\begin{lstlisting}[language=xml, caption={Příklad Klasifikátorů}, label=lst:klasifikator]
<vf:Data>
    <vf:Okresy>
        <vf:Okres>
            <oki:Kod>100</oki:Kod>
            <oki:Nazev>...</oki:Nazev>
        <\vf:Okres>
    </vf:Okresy>
    <vf:Obce>
        <vf:Obec>
            <obi:Kod>...</obi:Kod>
            <obi:Nazev>...</obi:Nazev>
            <obi:Okres>
            <oki:Kod>100<oki:Kod>
            </obi:Okres>
            <obi:MluvnickeCharakteristiky>
                <com:Pad2>...</com:Pad2>
                <com:Pad3>...</com:Pad3>
            </obi:MluvnickeCharakteristiky>
        </vf:Obec>
    </vf:Obce>
</vf:Data>
\end{lstlisting}

\newpage

\subsection{Atributy Objektů}
V tabulce \ref{tab:datove_typy} byly zmíněné všechny datové typy a jejich rozdíly mezi databázemi.
Podle dokumentace RÚIAN VFR \cite{ruian_vfr} každý atribut objektu má také svůj datový typ.
Mezi datovými objektů se nachází:
\begin{itemize}
    \item \textbf{String} -- textový řetězec, který může obsahovat písmena, číslice a~speciální znaky.
    \item \textbf{Integer} -- celé číslo bez desetinné části.
    \item \textbf{Long} -- reálné číslo s~desetinnou částí.
    \item \textbf{Boolean} -- logická hodnota, která může nabývat hodnoty true nebo false.
    \item \textbf{DateTime} -- datum a~čas ve formátu YYYY-MM-DDTHH:MM:SS.
    \item \textbf{Kolekce} -- seznam objektů nebo hodnot, které jsou uloženy v~jednom atributu.
\end{itemize}

Datové typy jako \texttt{String}, \texttt{Integer}, \texttt{Boolean} a~\texttt{Long} jsou standardní datové typy.
Ovšem zmíněné \texttt{Kolekce} jsou označeny všechny atributy, které obsahují více hodnot nebo cizí klíče.
Kolekce budou do databáze ukládány jako \textbf{JSON}.

\subsubsection*{JSON Objekty}
Proč byly zvoleny JSON objekty? Tabulky dle specifikace nebyly vhodné pro rozdělení na další tabulky a~vytváření cizích klíčů.
Některé kolekce totiž mohou být 1:1 nebo N:M. Proto byl zvolen JSON formát, který je vhodný pro ukládání takových to dat.
Některé kolekce jsou uloženy jako JSON Objekt a některé jako JSON pole (Pole JSON Objektů).
Byl proto vytvořen pro každou kolekci vlastní JSON mapovací metoda. Každá tato metoda funguje podobně jako XML parser.
Hledá elementy, které jsou uloženy v~kolekci a~převede je na JSON objekt nebo pole.
Všechny atributy, které se mohou vyskytnout json definován jako konstanty v modulu \texttt{jsonObjects} s příslušným jménem k objektu.

\subsubsection*{Kolekce JSON Objekt}
Tyto kolekce vždy obsahují pouze jeden JSON Objekt.
Proto byl vytvořen pro každou kolekci vlastní metoda, která parsuje danou kolekci.
Jedná se o~kolekce:
\begin{itemize}
    \item \textbf{Mluvnické Charakteristiky} -- metoda \texttt{readMCh()}
    \item \textbf{Čísla domovní} -- metoda \texttt{readCislaDomovni()}
    \item \textbf{Nespravné Údaje} -- metoda \texttt{readNespravneUdaje()}
\end{itemize}

\subsubsection*{Kolekce JSON Pole}
Tyto kolekce mohou obsahovat jednu nebo více Objektů.
Proto byl vytvořen pro každou kolekci vlastní metoda, která parsuje danou kolekci.
Jedná se o kolekce:
\begin{itemize}
    \item \textbf{Bonitované díly / Bonitovaný díl} -- metoda \texttt{readBonitovaneDily()} a \texttt{readBonitovanyDil()}
    \item \textbf{Způsoby ochrany / Způsob ochrany} -- metoda \texttt{readZpusobyOchrany()} a \texttt{readZpusobOchrany()}
    \item \textbf{DetailniTEA} -- metoda \texttt{readDetailniTeas()} a \texttt{readDetailniTea()}
\end{itemize}

V přírůstkových datech se nachází i další kolekce a to \textbf{Nezjištěné údaje}.
Ta je je kompletně ignorována a~neukládá se do databáze.


\subsubsection*{Kolekce s cizími klíči}
Jak již bylo zmíněno, cizí klíče jsou jako kolekce uloženy Integer nebo Long.
Vzhledem k tomu, že se jedná o~cizí klíče, které odkazují na jiné objekty,
byly vytvořeny metody pro parsování těchto cizích klíčů.
Metoda \texttt{readFK()} a \texttt{readFKLong} dostane jako parametr název elementu a vrací Integer nebo Long.
Rozdělení na Integer a Long je z důvodu, že je zde objekt \textbf{Parcela}, která má primární klíč jako Long.

\subsubsection*{Geometrie}
Geometrie je uložena speciální kolekce obsahující až 3 možné geometrické údaje.
V základní datové sadě se nachází pouze Definiční bod specifikující střed daného objektu na mapě.
V rozšířených se pak dodatečně nachází i Generalizované Hranice a Originální Hranice.
Je zde i případ Definiční čáry, která je uložena jako \texttt{LineString} nebo \texttt{MultiLineString}.
Tato geometrie se vyskytuje pouze u objektů \textbf{Ulice}.
O problematiku parsování geometrie se stará třída \texttt{GeometryParser} v modulu \texttt{geometry}, která parsuje jednotlivé geometrické objekty.
V současné práci se řeší pouze Definiční bod, který je uložen jako \texttt{Point} nebo \texttt{MultiPoint}.
Generalizované Hranice a Originální Hranice jsou uloženy jako \texttt{Polygon} nebo \texttt{MultiPolygon}.
Stejně jako u JSON objektů i geometrie se čte podle eventu a atributů v elementu.
Názvy geometrických objektů jsou uloženy jako konstanty v modulu \texttt{geometryParserConsts} s příslušným jménem k objektu.
Výstupem všech metod pro parsování geometrie je \texttt{Geometry} objekt z knihovny \texttt{JTS}.


\subsection{Dto objekty}
\subsection{Repositáře}
\subsection{Service třídy}
\subsection{Validace dat}
\subsection{Ukládání dat do databáze}